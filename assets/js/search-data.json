{
  "0": {
    "id": "0",
    "title": "",
    "content": "404 Page not found :( The requested page could not be found.",
    "url": "https://smoketeer.github.io/fall/404",
    "relUrl": "/404"
  },
  "1": {
    "id": "1",
    "title": "ascentController",
    "content": "ascentController AscentController is a vector oriented controller, it contains methods that will guide your rocket during the very first stage of flight - an ascent. Currently capable only of launch due to east(heading(90, x)). : Constructing Public methods getSteering() getThrottle() completed() passControl(bool) Code examples Constructing parameters type default Description desiredAp float - Desired apoapsis pitchVelocity* float 80 Velocity at which pitchover will start pitchDegrees* float 10 By how many degress to pitchover aoa* float 5 Angle of Attack relative to prograde * optional parameters Public methods public methods return type Description getSteering() Direction returns steering direction getThrottle() Float returns throttle precentage completed() Boolean is apoapsis larger than desired? passControl(bool) None passes control getSteering() No parameters Returns steering direction. getThrottle() No parameters Returns throttle percentage. completed() No parameters By default returns if current ship:apoapsis is larger than desired apoapsis defined when constructing. passControl(bool) Parameters: isUnlocking:Boolean -&gt; should throttle and steering be unlocked? Takes control over both steering and throttle until completed() returns true. Code examples // contructing without optional parameters local ascent is ascentController(30000). // passing control ascent[&quot;passControl&quot;](false) // ascent completed // contructing with optional parameters local ascent is ascentController(37000, 90, 10, 5). // manually defining control lock steering to ascent[&quot;getSteering&quot;](). lock throttle to ascent[&quot;getThrottle&quot;](). wait until ascent[&quot;completed&quot;](). // ascent completed",
    "url": "https://smoketeer.github.io/fall/docs/controllers/ascentController",
    "relUrl": "/docs/controllers/ascentController"
  },
  "2": {
    "id": "2",
    "title": "boostbackController",
    "content": "boostbackController BoostbackController is a vector oriented controller, it contains methods that will guide your rocket during so called boostback maneuver. : Constructing Public methods getSteering() getThrottle() completed() passControl(bool) Code examples Constructing parameters type default Description ldata landingDataModel - landingDataModel object that constructed with desired landing position errorScaling* float 1 How sensitive the controller is to error * optional parameters Public methods public methods return type Description getSteering() Direction returns steering direction getThrottle() Float returns throttle precentage completed() Boolean is current impact position in proximity to desired landing position? passControl(bool) None passes control getSteering() No parameters Returns steering direction. getThrottle() No parameters Returns throttle percentage. completed() No parameters By default returns if current impact position is in proximity of desired landing position. passControl(bool) Parameters: isUnlocking:Boolean -&gt; should throttle and steering be unlocked? Takes control over both steering and throttle until completed() returns true. Code examples // defining landingDataModel local ldata is landingDataModel(target:geoposition). // contructing boostbackController without optional parameter local boostback is boostbackController(ldata). // passing control boostback[&quot;passControl&quot;](). // boostback completed // defining landingDataModel local ldata is landingDataModel(target:geoposition). // contructing boostbackController without optional parameter local boostback is boostbackController(ldata). // manually accessing control lock throttle to boostback[&quot;getThrottle&quot;](). lock steering to boostback[&quot;getSteering&quot;](). wait until boostback[&quot;completed&quot;](). // boostback completed",
    "url": "https://smoketeer.github.io/fall/docs/controllers/boostbackController",
    "relUrl": "/docs/controllers/boostbackController"
  },
  "3": {
    "id": "3",
    "title": "Custom components",
    "content": "Custom components Advanced topic As mentioned in Simulating objects section FALL makes use of aggregation. This approach reduces dependencies between defined structures, which simplifies the process of implementing custom components. : What is aggregation? Custom component example What is aggregation? The simplest practical explanation goes like this: instead of constructing objects inside other objects, we pass them to their constructor: // aggregation function classA { // return lexicon } function classB { parameter someObject. // return lexicon } local A is classA(). // new A object local B is classB(A). // new B object rather than: // composition function classA { // return lexicon } function classB { local someObject is classA(). // new A object // return lexicon } local B is classB(). // new B object Custom component example landingController is constructed with hoverslamModel object. Let’s assume that you came up with an impressive solution that calculates suicide burn so accurately that FALL hoverslamModel looks like a silly toy. All you need to know is that hoverslamModel implements only one public method getThrottle. First write your genius solution in the form of class: function geniusSuicideBurn { // genius custom code function getThrottle { // returns throttle } return lexicon( // other public methods &quot;getThrottle&quot;, getThrottle@ ) } Now you can construct landingController with your genius solution: // prep local ldata is landingDataModel(target:geoposition). local geniusBurn is geniusSuicideBurn(). local landing is landingController(ldata, geniusBurn). In this case the landingController uses your custom solution to control the throttle, but keeps its way of steering the rocket. Simplicity of this approach makes it easier to develop new compatible components. Though it’s worth to mention that lack of type checking and inheritance model can be problematic and that’s exactly why I seriously consider actually implementing OOP layer on top of KOS.",
    "url": "https://smoketeer.github.io/fall/docs/introduction/components",
    "relUrl": "/docs/introduction/components"
  },
  "4": {
    "id": "4",
    "title": "Controllers",
    "content": "Controller Type Objects Any object that implements following public methods is considered a controller type object: object[&quot;getThrottle&quot;]() -&gt; returns throttle percentage object[&quot;getSteering&quot;]() -&gt; returns vector or direction object[&quot;completed&quot;]() -&gt; returns true if controller has done its job Location Controller classes are located in /controllers/ directory of FALL: 0:/fall/controllers/ Types Currently FALL implements following types of controllers: Vector oriented: not the greatest precision require little to no tuning rely on vector calculations PID oriented: can get extremely accurate rely on PID loops require an understanding of PID loop tuning have PID in their name",
    "url": "https://smoketeer.github.io/fall/docs/controllers",
    "relUrl": "/docs/controllers"
  },
  "5": {
    "id": "5",
    "title": "Docs",
    "content": "Documentation This section is considered the core of FALL documentation. It contains information related to currently supported structures. Majority of FALL structures simulate the very basic object behavior and are divided into three groups(types): Models Controllers Utilities Disclaimer IMPORTANT NOTE KOS FALL module has been made for fun, practical use and educational purposes. Even though the documentation is quite exhaustive(maybe even too exhaustive), please keep in mind that I consider it as just a hobby project.",
    "url": "https://smoketeer.github.io/fall/docs/",
    "relUrl": "/docs/"
  },
  "6": {
    "id": "6",
    "title": "Code Example",
    "content": "Code Example Tutorial In this section we’re going to build our very first script that uses FALL module. It’s assumed that you’re using stock KSP aerodynamic model and know the basics of Kerbal Operating System mod. Goals and requirements Mission sequence: Liftoff Pitchover at velocity of 90 m/s, by 10 degrees with 3 degrees aoa Ascent until apoapsis &gt; 8000 meters and then turn off the engine Land safely Rocket should: Have RCS thrusters, preferably at the top Be able to turn retrograde when falling What do we need? Because our goal is to perform an ascent and then safely touchdown, we’re going to use only two structures: ascentController hoverslamModel Implementation First let’s import the structures we need: runoncepath(&quot;0:/fall/controllers/ascentController&quot;). runoncepath(&quot;0:/fall/models/hoverslamModel&quot;). Now we initialize new ascentController object with previously defined parameters: // -- [ Prelaunch ] - local ascent is ascentController(8000, 90, 10, 3). Short launch sequence(assuming the rocket is held by clamps) can be written as: // -- [ Launch ] - stage. // turn on engines lock throttle to 1. stage. // release clamps Rocket is now lifting off, but isn’t steered in any way. Let’s give full control to our ascent object: // -- [ Ascent ] - ascent[&quot;passControl&quot;](). At this stage the rocket will perform ascent until apoapsis(8000 meters) goal is reached. Then the engine will shutdown. Oh no! Don’t panic. First we will turn retrograde, and wait until the rocket is falling. // -- [ Shutdown ] -- RCS ON. lock steering to ship:srfretrograde. wait until ship:verticalspeed &lt; 0. // waiting for descent And now we will safely land thanks to the magic(not really) of hoverlsamModel object: // -- [ Landing ] // number 10 comes from the height of the rocket in meters // it&#39;s advised to overshoot it a little bit(by say 3-5 meters) local hoverslam is hoverslamModel(10). lock throttle to hoverslam[&quot;getThrottle&quot;](). wait until ship:status = &quot;splashed&quot; or ship:status=&quot;landed&quot;. // We&#39;ve landed! Code in its entirety looks like this: runoncepath(&quot;0:/fall/controllers/ascentController&quot;). runoncepath(&quot;0:/fall/models/hoverslamModel&quot;). // -- [ Prelaunch ] - local ascent is ascentController(8000, 90, 10, 3). // -- [ Launch ] - stage. lock throttle to 1. stage. // -- [ Ascent ] - ascent[&quot;passControl&quot;](). // -- [ Shutdown ] -- RCS ON. lock steering to ship:srfretrograde. wait until ship:verticalspeed &lt; 0. // waiting for descent // -- [ Landing ] local hoverslam is hoverslamModel(10). lock throttle to hoverslam[&quot;getThrottle&quot;](). wait until ship:status = &quot;splashed&quot; or ship:status=&quot;landed&quot;. // We&#39;ve landed! More Tutorials",
    "url": "https://smoketeer.github.io/fall/quickstart/example",
    "relUrl": "/quickstart/example"
  },
  "7": {
    "id": "7",
    "title": "glideController",
    "content": "glideController GlideController is a vector oriented controller, it contains methods that will guide your rocket through glide towards target maneuver. During the descent glidePIDController will adjust the course only through means of control surfaces and RCS controls. : Contructing Public methods getSteering() getThrottle() completed() passControl(bool) Code examples Contructing parameters type default Description ldata landingDataModel - landingDataModel constructed with desired landing position aoa* float 10 max angle of attack relative to retrograde vector errorScaling* float 1 how sensitive the controller is to error * optional parameters Public methods public methods return type Description getSteering() Direction returns steering direction getThrottle() Float returns 0 completed() Boolean is throttle larger than 0? passControl(bool) None passes control getSteering() No parameters Returns steering direction. getThrottle() No parameters Because gliding is unpowered flight, always returns 0. completed() No parameters Returns true if throttle is larger than 0. passControl(bool) Parameters: isUnlocking::Boolean -&gt; should throttle and steering be unlocked? Takes control over both steering and throttle until completed() returns true. Code examples local ldata is landingDataModel(target:geoposition). local glide is glideController(ldata). lock steering to glide[&quot;getSteering&quot;](). local ldata is landingDataModel(target:geoposition). // max aoa of 5 local glide is glideController(ldata, 5). lock steering to glide[&quot;getSteering&quot;]().",
    "url": "https://smoketeer.github.io/fall/docs/controllers/glideController",
    "relUrl": "/docs/controllers/glideController"
  },
  "8": {
    "id": "8",
    "title": "glidePIDController",
    "content": "glidePIDController GlidePIDController is a PID oriented controller, it contains methods that will guide your rocket through glide towards target maneuver. During the descent glidePIDController will adjust the course only through means of control surfaces and RCS controls. : Contructing Public methods getSteering() getThrottle() completed() passControl(bool) Code examples Contructing parameters type default Description ldata landingDataModel - landingDataModel constructed with desired landing position Kp float - proportional response Ki* float 0 integral response Kd* float 0 derivative response minOut* float -10 minimal PID output(basically aoa difference) maxOut* float 10 maximal PID output(aoa difference) * optional parameters Public methods public methods return type Description getSteering() Direction returns steering direction getThrottle() Float returns 0 completed() Boolean is throttle larger than 0? passControl(bool) None passes control getSteering() No parameters Returns steering direction. getThrottle() No parameters Because gliding is unpowered flight, always returns 0. completed() No parameters Returns true if throttle is larger than 0. passControl(bool) Parameters: isUnlocking::Boolean -&gt; should throttle and steering be unlocked? Takes control over both steering and throttle until completed() returns true. Code examples // minimal tuning because gliding doesn&#39;t have to be // exceptionally precise in most cases local ldata is landingDataModel(target:geoposition). local glide is glidePIDController(ldata, 2000). lock steering to glide[&quot;getSteering&quot;](). local ldata is landingDataModel(target:geoposition). // max aoa of 5 and derivative response local glide is glidePIDController(ldata, 2000, 0, 500, -5, 5). lock steering to glide[&quot;getSteering&quot;]().",
    "url": "https://smoketeer.github.io/fall/docs/controllers/glidePIDController",
    "relUrl": "/docs/controllers/glidePIDController"
  },
  "9": {
    "id": "9",
    "title": "hoverSlamModel",
    "content": "hoverSlamModel HoverSlamModel makes calculations and holds data related to performing the final burn. It calculates throttle levels and when the engines should fire with equations of motion. : Contructing Public methods getThrottle() Code examples Contructing parameters type default Description bias float - how high is your rocket, advised to overshoot this value a little maxTwr* float -1 maximum TWR during final burn, if it’s less than 0, hoverSlamModel will automatically calculate maximal possible TWR * optional parameters Public methods public methods return type Description getThrottle() float returns throttle percentage getThrottle() No parameters Returns throttle percentage. The method uses numerical solution with equations of motion to predict when the burn should start. Code examples Give code examples // let&#39;s assume we are on our descent // our rocket is 15 meters high local hoverslam is hoverSlamModel(15). // new hoverSlamModel object lock steering to ship:srf:retrograde. lock throttle to hoverslam[&quot;getThrottle&quot;](). // locking throttle // at some point hoverslam will apply the throttle in such a way // that ideally our velocity should become 0 m/s at 0 meters above // terrain level. wait until ship:status = &quot;landed&quot; or ship:status = &quot;splashed&quot;. lock throttle to 0.",
    "url": "https://smoketeer.github.io/fall/docs/models/hoverSlamModel",
    "relUrl": "/docs/models/hoverSlamModel"
  },
  "10": {
    "id": "10",
    "title": "How to use",
    "content": "How to use The quickest way to start using FALL is simply running the file you need. KOS supports runoncepath command to run files. With its help you can access FALL structures: runoncepath(&quot;0:/fall/controllers/ascentController&quot;) // creating ascentController object local ascent is ascentController(35000, 90, 10, 3). FALL implements an importFall(&lt;structureName&gt;, &lt;copytopath&gt;*) utility, * in argument list means it’s optional: runoncepath(&quot;0:/fall/utilities/importFall&quot;) importFall(&quot;hoverSlamModel&quot;) // creating hoverSlamModel object local hoverslam is hoverslamModel(10). Calling structure methods Because Kerbal Operating System doesn’t natively support OOP and FALL simulates object behaviour with lexicons, you can access methods by key the following way: // creating new landingDataModel object local ldata is landingDataModel(ship:geoposition). // print impact geoposition print ldata[&quot;getImpact&quot;]().",
    "url": "https://smoketeer.github.io/fall/quickstart/howtouse",
    "relUrl": "/quickstart/howtouse"
  },
  "11": {
    "id": "11",
    "title": "importFall",
    "content": "importFall ImportFall utility improves code readability and makes it easier to import FALL structures. Unlike most structures in this module, importFall is a function, not an object. Calling parameters type default Description structureName string - what structure do you want to import? copyToPath* string ”” where do you want the structure to be copied? * optional parameters Code Example // First run importFall utility runoncepath(&quot;0:/fall/utilities/importFall&quot;). // now you can import any structure that FALL implements // if the second argument is omitted, files will be run directly // from FALL module directory(0:/fall/) importFall(&quot;landingDataModel&quot;) importFall(&quot;ascentController&quot;). importFall(&quot;boostbackController&quot;). // if you prefer to first copy files to specified location // and run them from there you can call importFALL with the second argument importFall(&quot;hoverSlamModel&quot;, &quot;hoverSlamModel&quot;) importFall(&quot;hoverSlamModel&quot;, &quot;0:/your/path/&quot;) Following code: // importing ascentController importFall(&quot;ascentController&quot;). // importing hoverSlamModel importFall(&quot;hoverSlamModel&quot;, &quot;hoverSlamModel&quot;). Is equivalent to: // importing ascentController runoncepath(&quot;0:/fall/controllers/ascentController&quot;) // importing hoverSlamModel copytopath(&quot;0:/fall/models/hoverSlamModel&quot;). runoncepath(&quot;hoverSlamModel&quot;). Use cases Let’s assume that you have a bootscript of your rocket looking like this: // BOOTSCRIPT copytopath(&quot;0:/myrocket&quot;, &quot;myrocket&quot;). run myrocket. It basically copies your main rocket script from 0:/ and runs it locally. If your “myrocket.ks” script uses FALL, you can run importFall utility in the boostscript: // BOOTSCRIPT runoncepath(&quot;0:/fall/utilities/importFall&quot;). copytopath(&quot;0:/myrocket&quot;, &quot;myrocket&quot;). run once myrocket. This way you can use importFall utility in your main rocket file: // MYROCKET SCRIPT importFall(&quot;hoverSlamModel&quot;, &quot;hoverSlamModel&quot;). importFall(&quot;ascentController&quot;, &quot;ascentController&quot;). importFall(&quot;landingController&quot;, &quot;landingController&quot;). // your rocket code",
    "url": "https://smoketeer.github.io/fall/docs/utilities/importfall",
    "relUrl": "/docs/utilities/importfall"
  },
  "12": {
    "id": "12",
    "title": "Home",
    "content": "Landing rockets like a boss FALL is a Fully Autonomous Launch and Landing module for KOS mod. This personal project has been refined and documented for educational and practical purposes. If you enjoy fun experiences with less explosions look no further, the magic is about to happen. Get started now View it on GitHub Unedited footage without distractions can also be found here. Dependencies Currently the module requires these two mods: Kerbal Operating System Trajectories Installation Download the zip file or clone repo and extract its contents to your archive directory path: $ ../KerbalSpaceProgram/Ships/Script/ Done! User Guide Quickstart Tutorials License KOS F.A.L.L. module is available under MIT License.",
    "url": "https://smoketeer.github.io/fall/",
    "relUrl": "/"
  },
  "13": {
    "id": "13",
    "title": "Installation",
    "content": "Installation As mentioned on the homepage, Download the zip file or clone the repo and extract its contents to your archive directory path: $ ../KerbalSpaceProgram/Ships/Script/ Can I move it around? You can keep the module anywhere you want, but remember that paths used in examples will assume that it’s placed in 0:/fall directory.",
    "url": "https://smoketeer.github.io/fall/quickstart/installation",
    "relUrl": "/quickstart/installation"
  },
  "14": {
    "id": "14",
    "title": "Introduction",
    "content": "Introduction In this section you will find general information related to philosophy, structure, and nomenclature used in this project and documentation. Nomenclature Because FALL simulates basic object behavior, the vocabulary used throughout this document will consist of well known OOP related terms: Objects Methods Constructors etc.",
    "url": "https://smoketeer.github.io/fall/docs/introduction",
    "relUrl": "/docs/introduction"
  },
  "15": {
    "id": "15",
    "title": "landingController",
    "content": "landingController LandingController is a vector oriented controller, it contains methods that will guide your rocket during the powered landing maneuver. During the final descent landingController will perform course corrections to mitigate error. Because it’s vector oriented, the results might not be the most accurate. : Contructing Public methods getSteering() getThrottle() completed() passControl(bool) Code examples Contructing parameters type default Description ldata landingDataModel - landingDataModel constructed with desired landing position hslam hoverSlamModel - hoverSlamModel object used to control the throttle aoa* float 5 maxmimum aoa relative to velocity vector errorScaling* float 1 how aggressive course corrections should be * optional parameters Public methods public methods return type Description getSteering() Direction returns steering direction getThrottle() Float returns throttle precentage completed() Boolean is the ship landed or splashed? passControl(bool) None passes control getSteering() No parameters Returns steering direction. getThrottle() No parameters Returns throttle percentage. Uses hoverSlamModel to calculate throttle. completed() No parameters By default returns true if the ship is splashed or landed. passControl(bool) Parameters: isUnlocking::Boolean -&gt; should throttle and steering be unlocked? Takes control over both steering and throttle until completed() returns true. Code examples local hoverslam is hoverSlamModel(15). // 15 is height of the rocket local landing is landingController(hoverslam, 10). // Passing control landing[&quot;passControl&quot;](). local hoverslam is hoverSlamModel(15). // 15 is height of the rocket local landing is landingController(hoverslam, 10). // Passing control lock steering to landing[&quot;getSteering&quot;](). lock throttle to landing[&quot;getThrottle&quot;](). wait until landing[&quot;completed&quot;]().",
    "url": "https://smoketeer.github.io/fall/docs/controllers/landingController",
    "relUrl": "/docs/controllers/landingController"
  },
  "16": {
    "id": "16",
    "title": "landingDataModel",
    "content": "landingDataModel LandingDataModel holds and calculates positional data related to impact and landing geoposition. : Contructing Public methods getSite() getImpact() lngError() latError() errorVector() overshoot(int) Code examples Contructing parameters type default Description landingSite geoposition - Desired landing geoposition * optional parameters Public methods public methods return type Description getSite() geoposition Returns landing site geoposition getImpact() geoposition Returns impact geoposition lngError() float Returns longitude error in degrees latError() float Returns latitude error in degrees errorVector() vector Returns a vector between landing and impact position overshoot(int) landingDataModel Returns new landingDataModel object with an overshoot getSite() No parameters Returns landing site geoposition. getImpact() No parameters Returns impact geoposition. lngError() No parameters Returns longitude difference between impact longitude and desired landing longitude. latError() No parameters Returns latitude difference between impact latitude and desired landing latitude. errorVector() No parameters Returns a vector between desired landing position and current impact position. overshoot(int) Parameters: meters::Integer -&gt; by how many should I overshoot original landing position? Returns new landingDataModel object with landingSite parameter shifted by distance defined in meters, in the direction of flight. Code examples Give code examples // before flight, we will choose a target(could be a mobile landing pad) wait until hastarget. local ldata is landingDataModel(target:geoposition). wait until hastarget. local ldata is landingDataModel(target:geoposition). . . . print ldata[&quot;errorVector&quot;]():mag. // prints how far impact point is from target // in meters wait until hastarget. local ldata is landingDataModel(target:geoposition). . . . // creating new landingDataModel, but the landing position // is being shifted by 50 meters in the direction of flight // from original landing position local overshootData is ldata[&quot;overshoot&quot;](50).",
    "url": "https://smoketeer.github.io/fall/docs/models/landingDataModel",
    "relUrl": "/docs/models/landingDataModel"
  },
  "17": {
    "id": "17",
    "title": "landingPIDController",
    "content": "landingPIDController LandingController is a PID oriented controller, it contains methods that will guide your rocket during the powered landing maneuver. During the final descent landingController will perform course corrections to mitigate error. Because it’s PID oriented, when properly tuned it can get extremely accurate. : Contructing Public methods getSteering() getThrottle() completed() passControl(bool) Code examples Contructing parameters type default Description ldata landingDataModel - landingDataModel constructed with desired landing position hslam hoverSlamModel - hoverSlamModel object Kp float - proportional response Ki* float 0 integral response Kd* float 0 derivative response minOut* float -10 minimal PID output(basically aoa difference) maxOut* float 10 maximal PID output(aoa difference) * optional parameters Public methods public methods return type Description getSteering() Direction returns steering direction getThrottle() Float returns throttle precentage completed() Boolean is the ship landed or splashed? passControl(bool) None passes control getSteering() No parameters Returns steering direction. getThrottle() No parameters Returns throttle percentage. Uses hoverSlamModel to calculate throttle. completed() No parameters By default returns true if the ship is splashed or landed. passControl(bool) Parameters: isUnlocking::Boolean -&gt; should throttle and steering be unlocked? Takes control over both steering and throttle until completed() returns true. Code examples local hoverslam is hoverSlamModel(15). // 15 is height of the rocket local landing is landingPIDController(hoverslam, 12000, 0, 500, -5, 5). // Passing control landing[&quot;passControl&quot;](). local hoverslam is hoverSlamModel(15). // 15 is height of the rocket local landing is landingPIDController(hoverslam, 10000). // Passing control lock steering to landing[&quot;getSteering&quot;](). lock throttle to landing[&quot;getThrottle&quot;](). wait until landing[&quot;completed&quot;]().",
    "url": "https://smoketeer.github.io/fall/docs/controllers/landingPIDController",
    "relUrl": "/docs/controllers/landingPIDController"
  },
  "18": {
    "id": "18",
    "title": "Models",
    "content": "Model Type Objects Models are responsible for holding and processing data , but do not offer enough control related methods to call them controllers. To put it simply - models hold data and calculate stuff, but can’t steer your ship. Location Model classes are located in /models/ directory of FALL: 0:/fall/models/",
    "url": "https://smoketeer.github.io/fall/docs/models",
    "relUrl": "/docs/models"
  },
  "19": {
    "id": "19",
    "title": "Simulating objects",
    "content": "Simulating object behavior Kerbal Operating System does not support OOP, nor does FALL implement an OOP layer on top of KOS. What it does however is make use of associative arrays in the form of lexicons to mimic object like behavior. Because KOS supports function delegates, lexicons can be utilised as a collection of functions accessed by keys. On top of that each function delegate “remembers” its local scope. : Why? How? Drawbacks Why? This approach makes the project well organised, modular and easy to use without having to worry about potential namespace flooding and wondering “is this function in this file or that file?”. Since each structure defined by FALL is independent through means of aggregation, it’s possible to expand the module more freely and allow users to define their own components. How? Take a look at this example written for KOS: // defining person &quot;class&quot; function person { parameter job is &quot;Unemployed&quot;. function getJob { // returns current job return job. } function setJob { // changes job parameter newJob. set job to newJob. } function eat { print job + &quot;: NOM NOM NOM!&quot;. } // returns functions return lexicon( &quot;getJob&quot;, getJob@, &quot;setJob&quot;, setJob@, &quot;eat&quot;, eat@ ). } We’ve defined a function, that returns lexicon of function delegates! Let’s test it: local firstPerson is person(). // creating new person object local secondPerson is person(). // creating new person object print firstPerson[&quot;getJob&quot;](). // prints &quot;Unemployed&quot; print secondPerson[&quot;getJob&quot;](). // prints &quot;Unemployed&quot; // changing the first persons job firstPerson[&quot;setJob&quot;](&quot;Programmer&quot;) print firstPerson[&quot;getJob&quot;](). // prints &quot;Programmer&quot; print secondPerson[&quot;getJob&quot;](). // prints &quot;Unemployed&quot; // the first person is hungry firstPerson[&quot;eat&quot;](). // prints &quot;Programmer: NOM NOM NOM!&quot; We’ve proven that the state of each person is: independent can be mutated only through available functions These results tell us that we’ve successfully simulated the core characteristics of objects in OOP: Identity behavior State Encapsulation Almost all of FALL structures are defined with this approach. Drawbacks There are drawbacks to every approach we can think of. In the case of FALL the very first thing that comes to mind is that this paradigm is probably not what creators of the KOS had in mind when designing the language. Another thing that I realise is that KOS is a great educational tool for non-programmers. I suspect that KOS was the very first encounter with programming for many people. It means that OOP vocabulary and philosophy may be outlandish to these individuals, which hurts the accessibility aspect of this module. Because FALL currently doesn’t implement a full blown OOP layer, this solution lacks type checking and inheritance.",
    "url": "https://smoketeer.github.io/fall/docs/introduction/objects",
    "relUrl": "/docs/introduction/objects"
  },
  "20": {
    "id": "20",
    "title": "Passing Control",
    "content": "Passing Control Advanced topic POSSIBLE CHANGES Each controller object implements a passControl method. It is a QoL feature that abstracts the most common way of using specific controller, but you can achieve the exact same results by using getThrottle, getSteering, completed methods. Even though passControl is considered QoL, it does have it’s quirks when it comes to gliding related controllers. If you’re a beginner I’d recommend avoiding passControl method in glideController and glidePIDController for the time being. : Blocking nature Unlocks control after execution How it works The Quirks How to deal with it When … then … Overloading Blocking nature Controller.passControl method is using wait to hold control until completed method returns true. It means that until certain condition is met, the passControl method will not fully execute. Unlocks control after execution By default passControl will unlock both steering and throttle at the end of execution. You can change this behavior by calling it with false argument. How it works Let’s consider two examples. First: local ascent is ascentController(35000, 90, 10, 3). lock steering to ascent[&quot;getSteering&quot;](). lock throttle to ascent[&quot;getThrottle&quot;](). wait until ascent[&quot;completed&quot;](). unlock steering. unlock throttle. and second: local ascent is ascentController(35000, 90, 10, 3). ascent[&quot;passControl&quot;](). Both do the exactly same thing. The Quirks Now that we know very basic logic of passControl, let’s consider glidePIDController object : local glide is glidePIDController(ldata, 2000). lock steering to glide[&quot;getSteering&quot;](). lock throttle to glide[&quot;getThrottle&quot;](). wait until glide[&quot;completed&quot;](). // what happens here? Which is equivalent to: local glide is glidePIDController(ldata, 2000). glide[&quot;passControl&quot;](false). // what happens here? By default glidePIDController[&quot;completed&quot;]() returns true only if the throttle is larger than 0 and gliding related controllers never apply any throttle. This means that if you don’t setup any kind of event before passing control, it will never fully execute. Currently this problem occurs only with glide related controllers. How to deal with it Even though passing control to glide controllers seems quite scary, there are ways to deal with their nasty nature. When … then … We can setup a when ... then ... before passing control: local glide is glidePIDController(ldata, 2000). when alt:radar &lt; 3000 then { lock throttle to 1. // or for example landingController[&quot;getThrottle&quot;]() } glide[&quot;passControl&quot;](false). Overloading We could also overload completed method: local landing is landingController(ldata). local glide is glidePIDController(ldata, 2000). glide[&quot;completed&quot;] = { return landing[&quot;getThrottle&quot;]() &gt; 0. } glide[&quot;passControl&quot;](). landing[&quot;passControl&quot;](). This way gliding controller will release control as soon as our landing controller wants to start the final burn.",
    "url": "https://smoketeer.github.io/fall/docs/controllers/passcontrol",
    "relUrl": "/docs/controllers/passcontrol"
  },
  "21": {
    "id": "21",
    "title": "Quickstart",
    "content": "Quickstart FALL revolves around the following first stage launch and recovery procedures: Ascent automation Boostback maneuver Gliding towards the target Precision landing FALL implements it’s structures in OOP resembling style. If you want to learn why and how it does it, please visit this page. Every Controller, Model and Utility is documented here. This section contains information necessary to install and use the module, as well as code examples.",
    "url": "https://smoketeer.github.io/fall/quickstart/",
    "relUrl": "/quickstart/"
  },
  "22": {
    "id": "22",
    "title": "Tutorials",
    "content": "Tutorials and resources In this section you’ll find helpful resources and step by step guides that show how to implement launch and landing scripts. Each guide assumes that you have FALL already installed and went through the quickstart.",
    "url": "https://smoketeer.github.io/fall/tutorials/",
    "relUrl": "/tutorials/"
  },
  "23": {
    "id": "23",
    "title": "Utilities",
    "content": "Utilities Utilities are functions and objects not directly related to launch and landing procedures. They are considered a QoL features which also improve code readability. Location Utility functions and classes are located in /utilities/ directory of FALL: 0:/fall/utilities/",
    "url": "https://smoketeer.github.io/fall/docs/utilities",
    "relUrl": "/docs/utilities"
  }
  
}
